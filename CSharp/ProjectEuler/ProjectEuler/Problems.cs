using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using NUnit.Framework;

namespace ProjectEuler
{
    public class Problems
    {
        /// <summary>
        /// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// </summary>
        [Test]
        public void Problem1()
        {
            var n = new HashSet<int>();
            var multiplier = 1;
            while (multiplier*3 < 1000)
            {
                n.Add(multiplier*3);
                if (multiplier*5 < 1000)
                    n.Add(multiplier*5);

                multiplier += 1;
            }
            Assert.AreEqual(233168, n.Sum());
        }

        /// <summary>
        /// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
        /// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
        /// </summary>
        [Test]
        public void Problem2()
        {
            var n = new List<int> { 1, 2 };
            int x, y, z;
            do
            {
                x = n[n.Count - 2];
                y = n[n.Count - 1];
                z = x + y;
                n.Add(z);
            } while (z < 4000000);

            Assert.AreEqual(4613732, n.Where(m => m % 2 == 0).Sum());
        }

        /// <summary>
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// What is the largest prime factor of the number 600851475143 ?
        /// </summary>
        [Test]
        public void Problem3()
        {
            var flip1 = new long[] {1, 13, 17, 29, 37, 41, 49, 53};
            var flip2 = new long[] { 7, 19, 31, 43 };
            var flip3 = new long[] { 11, 23, 47, 59 };
            const long limit = 13195;
            var sqrt = Math.Sqrt(limit);
            var numbers = new bool[limit + 1];
            for (int x = 1; x <= sqrt; x++)
            {
                for (int y = 1; y <= sqrt; y++)
                {
                    long n = (4 * (x * x)) + (y * y);
                    if (n <= limit && (flip1.Contains(n % 60)))
                        numbers[n] = !numbers[n];
                    
                    n = (3*(x * x)) + (y * y);
                    if (n <= limit && (flip2.Contains(n % 60)))
                        numbers[n] = !numbers[n];

                    n = (3 * (x * x)) - (y * y);
                    if (x > y && n <= limit && (flip3.Contains(n % 60)))
                        numbers[n] = !numbers[n];
                }
            }

            for (int x = 1; x <= sqrt; x++)
            {
                if (numbers[x])
                {
                    var x2 = x * x;
                    var multiplier = 1;
                    while (multiplier * x2 <= limit)
                    {
                        numbers[multiplier * x2] = false;
                        multiplier += 1;
                    }
                }
            }

            var primes = new HashSet<int> {2, 3, 5};
            for (int x = 5; x <= limit; x++ )
            {
                if (numbers[x])
                    primes.Add(x);
            }

            // nothing above the sqrt can be a prime factor either way
            // so only need to calc primes up to that
            // once that list exists, work backward from highest prime
            // to find prime factor
            foreach (var prime in primes.Reverse())
            {
                if (limit%prime == 0)
                {
                    Debug.WriteLine(prime);
                }
            }
        }
    }
}

